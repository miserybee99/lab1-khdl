\section{\NoCaseChange{\tool} Internals}
\label{sec:tool}
In this section, we detail the implementation of \tool.
\tool uses the state-of-the-art Libafl~\cite{libafl} fuzzer.
%
Libafl's design allows the \tool to include its own feedback mechanism in the fuzzing mutation.
The bytes generated by Libafl are based on feedback obtained from previous fuzzing iterations, which helps uncover new paths and overcome barriers, e.g., such as public key comparisons, in the Solana program.

We describe how each of the four components depicted in \Cref{fig:architecture} is used to detect bugs.
Moreover, we leverage an exemplary program that suffers from two impactful bugs to describe \tool for ease of presentation.
\Cref{lst:msc} shows the code of this example program.
We chose this example because it showcases two of the more popular bugs in Solana.
This function allows a user to withdraw funds from a \emph{vault} managed by the program. 
%
\Cref{line:check2} in the function checks if the \emph{authority} account is authorized to withdraw funds from account \emph{vault}.
In contrast to Ethereum, Solana programs need a separate wallet account to store data.
In \Cref{line:check3}, the function also checks whether the \emph{vault} provided as an input is associated with the \emph{wallet\_info} account.
Finally, if account \emph{from} contains sufficient lamports, the transfer proceeds.
%
However, this program suffers from a \emph{missing signer check}: an attacker can provide account \emph{authority} without the actual owner of \emph{authority} knowing about this.
Hence, the attacker can transfer funds on behalf ob the actual \emph{authority} without proper authorization.
This vulnerability can be fixed by adding a signer check to the program, which is shown in~\Cref{line:signercheck}.
%
Furthermore, the program lacks an owner check to verify the integrity of the information stored in the \emph{wallet\_info} account.
In this case, an attacker can provide a forged \emph{wallet\_info} account with fake data that refers to any \emph{vault} managed by the program while supplying his own public key as the \emph{authority}.
This means that, even if the code includes the signer check in \Cref{line:signercheck}, an attacker could drain any \emph{vault} associated to the program.
The check in \Cref{line:ownercheck} prevents this, as it verifies that the information in \emph{wallet\_info} is trusted.
Therefore, even if an attacker passes a fake account to the program, the program recognizes that this account does not contain the program's \emph{program\_id} as owner.
Thus, this check mitigates illegal lamport withdrawal.
Note that \tool is detecting these bugs without access to the program's source code. 

\subsection{Blockchain Emulator}\label{sec:blockchain-init}
The \blockemu allows \tool to model a valid \ledgersnap.
When creating a \ledgersnap, the \blockemu deploys several accounts: 
\begin{inparaenum}[(1)]
    \item a \emph{user} and \emph{attacker} wallet account, which are used by the oracles to determine whether a transaction triggered a potential security vulnerability
    \item on-chain programs such as the program to fuzz or the \emph{SPL Token program}
    \item \emph{sysvar} accounts, enabling programs to use their functions to receive \emph{cluster information}
    \item attacker-controlled accounts, which attempt to exploit potential missing owner check vulnerabilities.
\end{inparaenum}

\input{code/msc}

The \blockemu provides all these accounts and their public keys to the transaction generator for generating transactions.
%
The example in \Cref{lst:msc} requires three accounts: the \emph{wallet\_info}, \emph{vault} and \emph{authority} accounts with their respective data.
If these accounts are not available, the transaction fails.
\tool generates all three accounts and deploys them on the blockchain.
%
The \blockemu additionally provides the \emph{user}'s and \emph{attacker}'s private keys, as well as the public keys of Solana's native programs---which do not need to be deployed on the blockchain as they are integrated in the Solana runtime.
%
Finally, it also implements a \emph{PDA generator} and an \emph{attacker-controlled accounts generator}, which receive information about the runtime from the transaction evaluator.

\paragraph{PDA Generator}
The PDA generator derives PDAs based on the information provided by the PDA seed structures. 
The seed structures are extracted by the \emph{PDA seed structure extractor} (cf. \Cref{sec:program-semantic-extractors}) and received by the transaction evaluator.
The generator creates user-related and attacker-related PDAs by inserting the user's and the attacker's public key at the precise seed positions at which the program expects a public key. 
Furthermore, the generator inserts statically extracted seeds in places where the PDA seed structure extractor could not determine the origin of the seed.
In the case that no seed exists in a PDA seed structure that originates from a public key, the PDA generator derives a single PDA without reference to the user or attacker.
Finally, the PDA generator provides each derived PDA to the transaction generator for generating transactions.

\paragraph{Attacker-controlled Accounts Generator}
This generator uses information about the location of public keys from the account data---extracted by the \emph{account data structure extractor} (cf. \Cref{sec:program-semantic-extractors}) and received by the transaction evaluator---to create attacker-controlled accounts populated with malicious data and deploys them on the \ledgersnap. 
Here, the generator populates the attacker-controlled account data with public keys of user-related accounts and the public key of the attacker at positions at which the program expects public keys.
Hence, an extracted account structure must contain at least two public keys for the generator to generate attacker-controlled accounts.
By generating attacker-controlled accounts containing malicious data, \tool aims to detect potential missing owner check vulnerabilities.
In \Cref{lst:msc}, this applies to the wallet account \emph{wallet\_info} with an account \emph{authority} by comparing \emph{wallet\_info's} data with the public key of \emph{authority}. 
%
Since the program does not contain an owner check, \tool treats the \emph{wallet\_info} account as attacker controlled. 
Lastly, the attacker-controlled accounts generator provides the public key of each generated attacker-controlled account to the transaction generator.

\subsection{Transaction Generator}\label{sec:transaction-gen}

\begin{figure*}[t]
\centering
\includegraphics[width=0.7\linewidth]{figures/instruction_generation_structure.pdf}
\caption{Process to transform randomly generated bytes into a valid transaction}
\label{fig:instruction_generation_structure}
\end{figure*}
The transaction generator allows \tool to create valid and reproducible Solana transactions, effectively simulating real transactions. 
This component receives generated bytes from the fuzzer, and blockchain information from the \blockemu.
This includes information regarding the public keys of the selectable accounts, the last blockhash, and accounts capable of signing a transaction

As each transaction consists of at least one instruction, the generator first generates instructions from the received bytes, and then includes the remaining elements of a transaction, including the signature list, blockhash, and sorted account list (see \cref{sec:sol-analysis}). 

\cref{fig:instruction_generation_structure} shows the process and pattern the transaction generator applies to transform the generated bytes of the fuzzer into a valid Solana instruction.
The pattern can be mainly divided into four steps: \emph{i)} number of accounts, \emph{ii)} information about the account signing the transaction containing the instruction, \emph{iii)} information about the accounts contained in the instruction, \emph{iv)} and information about the instruction data contained in the instruction.
Regarding \Cref{lst:msc}, in step \emph{iii)}, the \blockemu extracts the accounts used in the instruction, and deploys accounts for \emph{wallet\_info}, \emph{vault}, and \emph{authority}.

For example, the number of accounts generated for the transaction is defined by a one-byte field.
This field  defines how many accounts the generator should insert in the instruction, considering the maximum number of selectable accounts provided by the \blockemu.
Similarly, the remaining bytes provided by the fuzzer are structured to create valid transactions and accounts.
Here, FuzzDelSol takes dependencies between these fields into account:
For instance, the number of generated accounts directly affects the account and signer information fields.
The instruction bytes information field uses the raw bytes generated by the fuzzer as instruction data.
After transforming the bytes into a valid instruction, with all the required information, the transaction generator creates an associated transaction for that instruction.

\subsection{RunDelSol}\label{sec:rundelsol}
RunDelSol executes the previously generated transactions in the Solana runtime environment. 
Since RunDelSol uses the real Solana environment, \tool can provide cluster information to the executed Solana program to fuzz and allow invoking other programs deployed on the blockchain (on-chain programs) and integrated in the runtime (native programs) using CPI.
Moreover, RunDelSol instantiates the Solana program to fuzz in an instrumented eBPF VM in Interpreter mode and executes it based on the \ledgersnap generated by the \blockemu. 
RunDelSol includes an instrumented eBPF VM, which extends the execution environment with \emph{coverage information}, data-flow tracing with \emph{taint tracking}, the implementation of six \emph{bug oracles} to detect potential vulnerabilities, and the extraction of \emph{Solana-specific program semantics}. 

\subsubsection{Coverage Information}
The instrumented eBPF VM of RunDelSol extracts coverage information during program execution. 
Here, RunDelSol examines each transition in the control flow graph, i.e., each \texttt{JMP}, \texttt{CALL}, and \texttt{RET} eBPF-instruction, and computes an index for that transition as follows: 
Let \emph{src} be the program counter of the eBPF \texttt{JMP}, \texttt{CALL} or \texttt{RET} instruction and \emph{dst} be the program counter of the target instruction of the transition, then the index of the transition is \( i \leftarrow (\emph{src} + \emph{dst}) \mod \emph{s}\), where \emph{s} is the size of the \emph{coverage array}.
%
The indices of the \emph{coverage array} provide information about whether the program executed this transition.
After the instrumented eBPF VM terminates, RunDelSol forwards the received coverage information of the executed instruction to the transaction evaluator. 

\subsubsection{Taint Tracking Engine}
\label{par:taint_tracking_engine}
The taint tracking engine provides fine-grained tracing of data-flows during program execution.
RunDelSol instruments memory addresses and register indices used by \texttt{LOAD}, \texttt{STORE} and \texttt{MOV} instructions.
The Data-flow tracing is enabled for the following three events. 
First, \tool traces data of accounts located on the \emph{program input} (cf. \cref{fig:program_input_layout}) and account public keys read by the program.
In \Cref{lst:msc} \tool traces the data of account \emph{wallet\_info}, because its data is read in \Cref{line:check2,line:check3}.
\tool also traces the public keys of the \emph{vault} and \emph{authority} accounts for the same reason.
Second, the taint tracking engine starts tainting memory addresses where the program stores the return values of Solana-specific syscalls for deriving PDAs. 
Tainting these memory addresses is crucial, as the program can use them in its execution instead of the public keys of the accounts located on the program input. 
Third, we taint register indices where the program stores an overflow or underflow value as a result of an arithmetic eBPF-instruction.

\begin{figure}[t]
\centering
\includegraphics[width=\columnwidth]{figures/msc.pdf}
\caption{Interaction of the taint tracking engine and the missing signer check oracle}
\label{fig:missing_signer_check_oracle_combination_taint_tracking_engine}
\end{figure}

\subsubsection{Bug Oracles}\label{sub:oracle}
RunDelSol implements six bug oracles in the instrumented eBPF VM, to find the following vulnerabilities:
\emph{i)} missing signer check, \emph{ii)} missing owner check, \emph{iii)} arbitrary cross program invocation, \emph{iv)} missing key check, \emph{v)} integer bugs, \emph{vi)}, and a lamports-based bug oracle to detect lamport-theft.
These oracles investigate eBPF-instructions, leverage the taint tracking engine to trace data-flows between eBPF-instructions, and signal the instrumented eBPF VM if a transaction triggers a potential vulnerability. 
When signaling the eBPF VM, each oracle specifies the reason for the crash and the program counter at which the crash occurs.
In the following, we will describe how these oracles work.

\paragraph{Missing Signer Check Oracle}
\Cref{lst:msc} suffers from a missing signer check.
\tool traces and analyzes the data-flow of this program to detect this vulnerability.
\Cref{fig:missing_signer_check_oracle_combination_taint_tracking_engine} describes this process:
The program reads data from the \emph{wallet\_info}, and public keys from the \emph{vault} and \emph{authority} accounts.
\Cref{algorithm:missing_signer_check} details the bug-detecting process for a missing signer check.
The oracle keeps track of mainly two things: accounts that the oracle marks as \emph{vulnerable}, and accounts that are marked as \emph{not vulnerable}.
Further, the oracle marks accounts as vulnerable if their public key or data are compared with another account without any of the accounts having signed the transaction (see Line~\ref{missing_signer_check_13}).
On the other hand, the oracle marks accounts as \emph{not vulnerable} if a comparison against an account that signed the transaction happens (see Line~\ref{missing_signer_check_16}).
The oracle signals the VM if the program writes to the lamports or data fields of an account that is marked as \emph{vulnerable} (see Line \ref{missing_signer_check_19} to \ref{missing_signer_check_21}).

Regarding the example in \Cref{lst:msc}, because of the checks in \Cref{line:check2,line:check3}, \tool marks the \emph{wallet\_info} account as \emph{vulnerable}.
%
Similarly, \tool marks the \emph{vault} and \emph{authority} accounts because their public keys are compared to the data of another account which also did not sign the transaction.
%
The oracle subsequently detects that the program writes a decreased amount of lamports in account \emph{vault}'s lamports field.
Since the account is marked as \emph{vulnerable} and is not previously compared to at least one public key of an account which signed the transaction, the oracle signals the VM.
However, after enabling the signer check in~\Cref{line:signercheck} of~\Cref{lst:msc}, \tool transitively marks all three accounts as non-vulnerable.

\begin{algorithm}
\caption{Missing Signer Check Oracle}
\label{algorithm:missing_signer_check}
\begin{algorithmic}[1]
        \State $k \gets \text{amount of accounts}$                          \label{missing_signer_check_1}
        \State $V \gets [\emptyset_1,\emptyset_2,...\emptyset_k]$           \label{missing_signer_check_2}
        \State $T \gets \emptyset$                                          \label{missing_signer_check_3}
        
        \While{program running}
            
            \If{program performs register comparison}                       \label{missing_signer_check_8}
                \State $a \gets \text{account in } src \text{ register}$    \label{missing_signer_check_9}
                \State $b \gets \text{account in } dst \text{ register}$    \label{missing_signer_check_10}
                \State $i \gets \text{index of account } a \text{ in } V$   \label{missing_signer_check_11}

                
                \If{$a$.data \textbf{is compared with} $b$.pubkey \textbf{and} $a \notin T$}    \label{missing_signer_check_12}
                    \If{\textbf{not} $a$ signed tx \textbf{and} \textbf{not} $b$ signed tx}                                      \label{missing_signer_check_13}
                        \State $V[i] \gets V[i] \cup \{a\} \cup \{b\}$                 \label{missing_signer_check_14}
                    \Else
                        \ForEach{$c \in V[i]$}                              \label{missing_signer_check_15}
                            \State $T \gets T \cup \{c\}$                   \label{missing_signer_check_16}
                        \EndFor
                        \State $V[i] \gets \emptyset$                       \label{missing_signer_check_17}        
                    \EndIf   
                \EndIf
                
            \EndIf
            
            \If{program writes to lamports or data of account $a$}          \label{missing_signer_check_18}
                \ForEach{$v \in V$}                                         \label{missing_signer_check_19}
                    \If{$a \in v$}                                          \label{missing_signer_check_20}
                        \State signal VM                                    \label{missing_signer_check_21}
                    \EndIf
                \EndFor
            \EndIf

        \EndWhile
\end{algorithmic}
\end{algorithm}

\paragraph{Missing Owner Check Oracle}
The \emph{missing owner check oracle} checks whether an eBPF \texttt{CMP} instruction compares data of an account that is \emph{not owned} by the program with the public key of another account.
In case the program performs such a comparison, the oracle marks the latter account as potentially vulnerable to a missing owner check, because the former account could be an attacker-controlled account in which the attacker could assemble data in such a way to reference arbitrary accounts.
\Cref{algorithm:missing_owner_check} details the bug-detecting process of the \emph{missing owner check oracle}.
The oracle operates as follows:
Before the program starts, the oracle initializes \emph{i)} a set $M$ in which it stores potentially malicious accounts (see Line \ref{missing_owner_check_1}) and \emph{ii)} a set of accounts $V$ that an attacker could potentially exploit using a missing owner check vulnerability (see Line \ref{missing_owner_check_2}).

At runtime of the program, the oracle checks if the program reads the data of an account $a$ which is not owned by the program, i.e., whose public key in the owner field is not equal to the program ID of the program (see Line \ref{missing_owner_check_3} and \ref{missing_owner_check_4}).
If the program does not own account $a$, the oracle marks $a$ as potentially malicious by adding it to set $M$ (see Line \ref{missing_owner_check_5}).

Moreover, the oracle checks at runtime whether the program compares account details of two account $a, b$ in registers (see Line \ref{missing_owner_check_6} to \ref{missing_owner_check_8}). 
In this comparison, if data from an account $a$ is compared to the public key of an account $b$, and $a$ is included in the set $M$ (see Line \ref{missing_owner_check_9}), the oracle marks $b$ as potentially vulnerable by adding $b$ to the set $V$ (see Line \ref{missing_owner_check_10}).
The same applies if the order of accounts in the register comparison is reversed, i.e., if the public key of account $a$ is compared with data of a account $b$ (see Line \ref{missing_owner_check_11} and \ref{missing_owner_check_12}). 
Thus, the oracle memorizes that the program has compared the data of an account potentially controlled by the attacker with the public key of another account.

The oracle signals the eBPF VM in case the program deducts lamports of an account which is contained in the set $V$, i.e., whose public key was previously compared with data of an account not owned by the program (see Line \ref{missing_owner_check_13} to \ref{missing_owner_check_17}).
The same applies when the program writes to the data field of an account contained in the set $V$ (see Line \ref{missing_owner_check_18} and \ref{missing_owner_check_19}).
This is because the oracle assumes that an owner check is missing because \emph{i)} the program compared the data of an account $a$ possibly controlled by the attacker with the public key of another account $b$ \emph{ii)} and then modified the lamports or data field of $b$.
An owner check would have already crashed the program, because the owner of the account whose data the program compared with a public key is not the program.

\begin{algorithm}
\caption{Missing Owner Check Oracle}
\label{algorithm:missing_owner_check}
\begin{algorithmic}[1]
        \State $M \gets \emptyset$           \label{missing_owner_check_1}
        \State $V \gets \emptyset$           \label{missing_owner_check_2}
        
        \While{program running}
            
            \If{program reads data of account $a$}                          \label{missing_owner_check_3}
                \If{$a$.owner $\neq$ program\_id}                           \label{missing_owner_check_4}
                    \State $M \gets M \cup \{a\}$                           \label{missing_owner_check_5}
                \EndIf
            \EndIf
            
            \If{program performs register comparison}                       \label{missing_owner_check_6}
                \State $a \gets \text{account in } src \text{ register}$    \label{missing_owner_check_7}
                \State $b \gets \text{account in } dst \text{ register}$    \label{missing_owner_check_8}

                \If{$a$.data \textbf{is compared with} $b$.pubkey \textbf{and} $a \in M$}       \label{missing_owner_check_9}
                    \State $V \gets V \cup \{b\}$                                               \label{missing_owner_check_10}
                \Else{ $a$.pubkey \textbf{is compared with} $b$.data \textbf{and} $b \in M$}    \label{missing_owner_check_11}
                    \State $V \gets V \cup \{a\}$                                               \label{missing_owner_check_12}
                \EndIf
            \EndIf
            
            \If{program writes to lamports field of account $a$}                \label{missing_owner_check_13}                   
                \State $l_{prev} \gets$ lamports of $a$ before write            \label{missing_owner_check_14}
                \State $l_{after} \gets$ lamports of $a$ after write            \label{missing_owner_check_15}
                \If{$a \in V$ \textbf{and}  $l_{after}$ $<$ $l_{prev}$}         \label{missing_owner_check_16}
                    \State signal VM                                            \label{missing_owner_check_17}
                \EndIf
            \EndIf
            
            \If{program writes to data of account $a$ \textbf{and} $a \in V$}   \label{missing_owner_check_18}                           
                \State signal VM                                                \label{missing_owner_check_19}
            \EndIf

        \EndWhile
%    \EndFunction
\end{algorithmic}
\end{algorithm}

Consider our example from~\Cref{lst:msc}.
Note that the code includes~\Cref{line:ownercheck} to show a valid owner check, i.e., in the example we assume that the code \emph{does not contain} the check at~\Cref{line:ownercheck}.
Due to the missing check, the oracle marks the \emph{vault} and \emph{authority} accounts as vulnerable, because in \Cref{line:check2,line:check3} their keys are compared to data read from the \emph{wallet\_info} account.
As \Cref{lst:msc} does not check the ownership of the \emph{wallet\_info} account, an attacker can forge this account such that his own public key assumes authority over the funds stored in any given \emph{vault} account.
To facilitate this, \tool uses the \emph{attacker-controlled accounts generator} (cf. \Cref{sec:blockchain-init}) to create attacker-controlled accounts that have references to accounts managed by the program as well as to the attacker to trigger operations on the accounts the program manages without verifying the owner of the account.
In this example, the attacker constructs the \emph{wallet\_info} account to contain his public key in the \emph{wallet.authority} field and the public key any given \emph{vault} account managed by the program in the \emph{wallet.vault} field.

Lastly, the oracle signals the VM as soon as an eBPF \texttt{STORE} instruction writes to the lamports or data field of any vulnerable account.
Note that when writing to a lamports field, the oracle signals the VM only if the \texttt{STORE} instruction decreases the account's lamports.
In our example, the oracle signals the VM at \Cref{line:vlamports}, because the program debits the \emph{vault} account, which is marked as vulnerable.

\paragraph{Lamports-based Oracle}
The \emph{lamports-based oracle} checks for user-related accounts that could lose lamports to an attacker-related account.
We illustrate the process for the \emph{lamports-based oracle} in~\Cref{algorithm:lamports_based_oracle}.
Before executing the program, the runtime initializes user-related and attacker-related accounts with PDAs (cf. \cref{sec:blockchain-init}) (see Line~\ref{lamports_based_oracle_1} and~\ref{lamports_based_oracle_2}).

This oracle is executed only if the issuer and signer of the transaction is the attacker (see Line~\ref{lamports_based_oracle_5}). 
Consider a program where the attacker passes user-related PDA seeds as a parameter:
An attacker could transfer lamports from user-related accounts to attacker-related accounts by specifying arbitrary seeds, despite proper owner and signer checks.

The lamports-based oracle checks eBPF \texttt{STORE} instructions to the lamports fields of accounts (see Line~\ref{lamports_based_oracle_6}).
Thus, the oracle checks each time if the program subtracts lamports from a user-related account (see Line~\ref{lamports_based_oracle_9} and \ref{lamports_based_oracle_10}) and credits lamports to an attacker-related account (see Line~\ref{lamports_based_oracle_11} and \ref{lamports_based_oracle_12}).
The oracle signals the VM if a program transfers lamports from a user-related account to an attacker-related account (see Line~\ref{lamports_based_oracle_13} and \ref{lamports_based_oracle_14}).
The lamports-based oracle only reports an error if neither the missing owner check, nor the missing signer check reports an error, since both oracles already check the lamports field.

\begin{algorithm}
\caption{Lamports-based Oracle}
\label{algorithm:lamports_based_oracle}
\begin{algorithmic}[1]
\State $U \gets \text{user related accounts}$                         \label{lamports_based_oracle_1}
\State $A \gets \text{attacker related accounts}$                     \label{lamports_based_oracle_2}
\State $\text{lamports}_{\text{user}}^{\text{lose}} \gets false$                        \label{lamports_based_oracle_3}
\State $\text{lamports}_{\text{attacker}}^{\text{gain}} \gets false$                  \label{lamports_based_oracle_4}
\While{program running \textbf{and} attacker signed tx}               \label{lamports_based_oracle_5}
    \State
    \If{program writes to lamports field of account $a$}                \label{lamports_based_oracle_6}                   
        \State $l_{prev} \gets$ lamports of $a$ before write \label{lamports_based_oracle_7}
        \State $l_{after} \gets$ lamports of $a$ after write        \label{lamports_based_oracle_8}

        \If{$a \in U$ \textbf{and}  $l_{after}$ $<$ $l_{prev}$}         \label{lamports_based_oracle_9}
            \State $\text{lamports}_{\text{user}}^{\text{lose}} \gets true$             \label{lamports_based_oracle_10}
        \ElsIf{$a \in A$ \textbf{and} $l_{after}$ $>$ $l_{prev}$}       \label{lamports_based_oracle_11}
            \State $\text{lamports}_{\text{attacker}}^{\text{gain}} \gets true$       \label{lamports_based_oracle_12}
        \EndIf
    \EndIf
    \State
    \If{$\text{lamports}_{\text{user}}^{\text{lose}} = \text{lamports}_{\text{attacker}}^{\text{gain}} = true$}                    \label{lamports_based_oracle_13}
        \State signal VM                                             \label{lamports_based_oracle_14} 
    \EndIf
\EndWhile
\end{algorithmic}
\end{algorithm}

\paragraph{Arbitrary CPI Oracle}
The \emph{arbitrary cross program invocation oracle} checks whether an eBPF \texttt{CALL} instruction calls the Solana-specific syscalls for invoking other programs using CPI.
In case the program executes such an instruction, the program checks whether a previously specified malicious key was passed to the syscall as the target program, which implies that an attacker is able to invoke his malicious program.
If a previously specified malicious key was passed as a target program to the syscall, the oracle signals the VM.

The oracle operates as follows:
Before starting the program, we define a malicious public key, which represents a malicious program controlled by the attacker (see Line \ref{arbitrary_cpi_line_1}).
At runtime of the program, the oracle then checks whether the program calls the functions \texttt{sol\_invoke\_signed\_rust()} or \texttt{sol\_invoke\_signed\_c()} (see Line \ref{arbitrary_cpi_line_2}). 
If this is the case, the oracle determines the public key of the called program (see Line \ref{arbitrary_cpi_line_3}). 
The oracle then checks if the public key of the program being invoked is equal to that of the previously defined malicious program (see Line \ref{arbitrary_cpi_line_4}).
This implies that an attacker is able to invoke his malicious program. 
If this is the case, the oracle signals the virtual machine (see Line \ref{arbitrary_cpi_line_5}).

\begin{algorithm}
\caption{Arbitrary CPI Oracle}
\label{algorithm:arbitrary_cpi}
\begin{algorithmic}[1]
\State $m_{pk} \gets \text{predefined malicious public key}$                                \label{arbitrary_cpi_line_1}
\While{program is running}
    \If{program calls \texttt{sol}\_\texttt{invoke}\_\texttt{signed}\_\texttt{rust()} \textbf{or} \texttt{sol}\_\texttt{invoke}\_\texttt{signed}\_\texttt{c()}}     \label{arbitrary_cpi_line_2}
        \State $i_{pk} \gets $ public key of invoked program                             \label{arbitrary_cpi_line_3}
        \If{$i_{pk} = m_{pk}$}                                                              \label{arbitrary_cpi_line_4}
                \State signal VM                                                            \label{arbitrary_cpi_line_5}
        \EndIf
    \EndIf
\EndWhile
\end{algorithmic}
\end{algorithm}

\paragraph{Missing Key Check Oracle}
The \emph{missing key check oracle} requires specifying the following two parameters before starting fuzzing: 
\emph{i)} the address of a function $f$ for which a key check is expected \emph{ii)} and an account \emph{a}, where the program is expected to compare the public key of an account it passes to function $f$ with the public key of account \emph{a} before calling function $f$.
In the case of Wormhole, $f$ would represent the function \emph{load\_instruction\_at} and \emph{a} would represent the \emph{KeccakSecp256k sysvar} account.
At program runtime, the oracle checks whether an eBPF \texttt{CALL} instruction calls the function $f$ and signals the VM if the program does not compare the public key of the account passed to the function $f$ with the public key of account \emph{a} before calling function $f$.

\Cref{algorithm:missing_key_check} details the bug-detecting process of the \emph{missing key check oracle}.
Before the program starts, we pass two parameters to the oracle: 
First, the address of a function $f$ for which a key check is expected (see Line \ref{missing_key_check_line_1}).
Second, the public key $a_{pk}$ of an account, where the program is expected to compare the public key of an account it passes to function $f$ with the public key $a_{pk}$ before calling function $f$ (see Line \ref{missing_key_check_line_2}).
In the case of Wormhole, $f$ would represent the function \emph{load\_instruction\_at} and $a_{pk}$ would represent the public key of the \emph{KeccakSecp256k sysvar} account.
Moreover, the oracle defines an empty list $A$, which it uses at program runtime to store accounts which public key was compared to $a_{pk}$ (see Line \ref{missing_key_check_line_3}). 

At program runtime, the oracle checks whether the program performs a register comparison operation or a function call operation.
In the case of the register comparison operation, the oracle uses the taint tracking engine to check whether the source and/or destination registers contain account details (see Line \ref{missing_key_check_line_5} and \ref{missing_key_check_line_6}). 
If at least one of the registers contains account details, the oracle checks whether the account details are the public key of an account and whether it is compared with $a_{pk}$ (see Line \ref{missing_key_check_line_7} and \ref{missing_key_check_line_9}). 
If this is the case, the oracle adds the account of the account details to the set $A$ to memorize that the account was compared with $a_{pk}$ before calling the function $f$ (see Line \ref{missing_key_check_line_8} and \ref{missing_key_check_line_10}).

In case the program calls the function $f$ using an eBPF \texttt{CALL} instruction (see Line \ref{missing_key_check_line_11}), the oracle extracts the account $p$ passed to the function (see Line \ref{missing_key_check_line_12}). 
Then the oracle checks if the account $p$ is not included in the set $A$ and thus was not compared with the public key $a_{pk}$ before calling the function $f$ (see Line \ref{missing_key_check_line_13}). 
If this is the case, the oracle signals the VM (see Line \ref{missing_key_check_line_14}).

\begin{algorithm}
\caption{Missing Key Check Oracle}
\label{algorithm:missing_key_check}
\begin{algorithmic}[1]
\State $f \gets \text{function address for which a key check is expected}$                                \label{missing_key_check_line_1}
\State $a_{pk} \gets \text{expected public key to be checked}$                     \label{missing_key_check_line_2}
\State $A \gets \emptyset$                                              \label{missing_key_check_line_3}

\While{program is running}

    \If{program performs register comparison}                           \label{missing_key_check_line_4}
        \State $a \gets \text{account in } src \text{ register}$   \label{missing_key_check_line_5}
        \State $b \gets \text{ account in } dst \text{ register}$   \label{missing_key_check_line_6}
        \If{$a_{pk}$ \textbf{is compared with} $b$.pubkey}        \label{missing_key_check_line_7}
            \State $A \gets A \cup \{b\}$                         \label{missing_key_check_line_8}
        \Else{ $a$.pubkey \textbf{is compared with} $a_{pk}$}     \label{missing_key_check_line_9}
            \State $A \gets A \cup \{a\}$                         \label{missing_key_check_line_10}
        \EndIf
    \EndIf

    \If{program calls function $f$}                                     \label{missing_key_check_line_11}
        \State $p \gets \text{passed account to function } f$                   \label{missing_key_check_line_12}
        \If{$p \notin A$}                                               \label{missing_key_check_line_13}
            \State signal VM                                            \label{missing_key_check_line_14}
        \EndIf
    \EndIf

\EndWhile
\end{algorithmic}
\end{algorithm}

\paragraph{Integer Bugs Oracle}
The \emph{integer bugs oracle} checks whether an eBPF \texttt{STORE} instruction writes an overflowed or underflowed value to the lamports field of an account. 
Subsequently, the oracle signals the VM.
To do so, this oracle leverages the taint tracking engine.
Note that the oracle is not applicable to the accounts' data field, since the Borsh serializer\footnote{\url{https://borsh.io/}}---which programs frequently use for serializing and deserializing account data---calculates overflow or underflow values when serializing data into the account's data field. 

\Cref{algorithm:integer_bugs} provides a detailed explanation of the \emph{integer bug oracle}.
The oracle operates as follows:
Before the program runs, the oracle initializes an empty list $T$ in which the oracle stores the registers that contain bugged values, i.e., overflowing or underflowing values (see Line \ref{integer_bugs_line_1}). 

At program runtime, the oracle then checks whether an eBPF \texttt{STORE} instruction has caused the program to write a value to a register (see Line \ref{integer_bugs_line_2}). 
If this case occurs, the oracle checks whether the value which the program writes into the register is bugged, i.e. has overflowed or underflowed (see Line \ref{integer_bugs_line_3}).
If a bugged value is written to the register, the oracle remembers the register by adding the register to the list $T$ (see Line \ref{integer_bugs_line_3} and \ref{integer_bugs_line_4}).
In case the program does not write a bugged value to the register, the oracle removes the register from the list $T$ (see Line \ref{integer_bugs_line_5}).

Moreover, the oracle checks if the program writes a value into the lamports field of an account at runtime (see Line \ref{integer_bugs_line_6}).
Then the oracle checks whether the set $T$ contains the register whose value the program writes to the lamports field of an account (see Line \ref{integer_bugs_line_7} and \ref{integer_bugs_line_8}).
This indicates that the program has written a bugged value to the lamports field of the account.
If the program writes a bugged value into the field, the oracle signals the VM (see Line \ref{integer_bugs_line_9}).

\begin{algorithm}
\caption{Integer Bugs Oracle}
\label{algorithm:integer_bugs}
\begin{algorithmic}[1]
\State $T \gets \emptyset$                                  \label{integer_bugs_line_1}
\While{program is running}
    \If{program writes $value$ to $src$ register}           \label{integer_bugs_line_2}
        \If{$value$ is bugged}                              \label{integer_bugs_line_3}
            \State $T \gets T \cup \{src\}$                 \label{integer_bugs_line_4}
        \Else
            \State $T \gets T \backslash \{src\}$           \label{integer_bugs_line_5}
        \EndIf    
    \EndIf
    
    \If{program writes $value$ to lamports field}           \label{integer_bugs_line_6}
        \State $src \gets \text{register holding } value$   \label{integer_bugs_line_7}
        \If{$src \in T$}                                    \label{integer_bugs_line_8}
            \State signal VM                              \label{integer_bugs_line_9}
        \EndIf
    \EndIf
\EndWhile
\end{algorithmic}
\end{algorithm}

\subsubsection{Program Semantic Extractors}
\label{sec:program-semantic-extractors}

\tool does not have access to a program's source code, and therefore RunDelSol implements a \emph{PDA seed structure extractor} and an \emph{account data structure extractor} to determine semantic program information.

\paragraph{PDA Seed Structure Extractor}
The PDA seed structure extractor extracts the structure and origin of the seeds used by the program to derive PDAs.
For this purpose, we use the taint tracking engine to determine the origin of the arguments of Solana-specific syscalls that derive PDAs.
This allows the PDA seed structure extractor to determine, for example, whether a seed originates from an account's public key.
In case no origin for a seed is available, we assume that the seed has been statically compiled into the program. 
Hence, the PDA seed structure extractor does not record the origin of the seed (e.g., a public key) but the actual bytes of the seed.

\paragraph{Account Data Structure Extractor}
The account data structure extractor extracts positions of public keys in the data structures of accounts.
The extractor checks whether the program writes a public key to the data field of an account located on the \emph{program input} (cf. \Cref{fig:program_input_layout}).
In \Cref{lst:msc}, the \emph{account data structure extractor} extracts the offsets of the \emph{wallet.authority} and \emph{wallet.vault} fields in the \emph{wallet\_info} account.
Note that this information is extracted during account initialization of the \emph{wallet\_info} account. 
Further, \tool leverages this information in subsequent fuzzing runs to populate the data fields of \emph{wallet\_info}-like accounts with existing public keys that may refer to either attacker-controlled accounts or program-managed accounts.
Regarding the program in \Cref{lst:msc}, this means that \tool creates a \emph{wallet\_info} account with the exact keys required to trigger a bug that leads to illegitimate gain of lamports.
Thus, the information persists across the independent transactions created by the fuzzer.
%
The \blockemu uses this information to deploy accounts on the blockchain which can trigger potential missing owner check vulnerabilities. 

\subsection{Transaction Evaluator}\label{sec:transaction-eval}
After RunDelSol finishes the execution of the transaction, RunDelSol forwards the coverage information to the transaction evaluator.
This includes the PDA seed structures, account data structures, and---if a bug was detected---the oracle signals, received at runtime.
The coverage information and oracle signals determine the input bytes of the next fuzzing iteration.
If the oracle signaled the eBPF VM, the transaction evaluator also creates a vulnerability report, that includes information to reproduce the transaction. 
In case RunDelSol extracted new PDA seed structures or account data structures, the transaction evaluator informs the \blockemu to generate a new \ledgersnap before starting the next fuzzing iteration.