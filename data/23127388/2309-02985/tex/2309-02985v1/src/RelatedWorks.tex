%\subsection{Failures in \iot development}
In this section, we review  \textit{i)} the most relevant Model-Driven Engineering (MDE) approaches applied in the context of IoT \textit{ii) }applications of mutation testing in fault analysis, and, \textit{iii)} specification mining in software verification.
 

\subsection{MDE for \iot development}
%As already said, the IoT context is characterized by a high level of complexity due to the huge number of heterogeneous software and hardware components. In the following, we report some approaches that exploit MDE techniques to deal with the intrinsic complexity of such a domain.   

 Ciccozzi \etal \cite{Ciccozzi2017} exploits the MDE paradigm to enable the abstraction of IoT systems. They propose exploiting the MDE paradigm to enable the abstraction of IoT systems, the easy handling of the various degrees of automation in software development, and the performance analysis of the system from different perspectives.
%
% Thramboulidis \etal \cite{Thramboulidis2017} developed an MDE approach to face the complexity of IoT-based cyber-physical manufacturing systems. The conceived languaghe authors developed a language devoted to manufacturing engineers to allow them the definition of cyber-physical and cyber components of the manufacturing system by relieving them of the task of integrating IoT protocols. Their experiments showed an increase in development productivity.

Thramboulidis \etal \cite{Thramboulidis2017} developed an MDE approach to face the complexity of IoT-based cyber-physical manufacturing systems. The conceived language allows domain experts to integrate IoT protocols during the system specification. 

%definition of cyber-physical and cyber components of the manufacturing system by relieving them of the task of integrating IoT protocols. Their experiments showed an increase in development productivity.

 ThingML \cite{ThingMLcore} is an IoT engineering platform that combines well-proven textual software-modeling constructs aligned with UML, such as statecharts and components, with an imperative platform-independent action language for developing IoT applications. 
 
 %In ThingML, a thing is defined by a set of properties, functions, messages, ports, and state machines, and these behaviors are local to a thing and can be accessed only through interfaces inside the state machines or functions.

Fortas \etal \cite{Fortas2022} exploit MDE techniques to build an approach supporting the development and testing of IoT applications. In particular, they use ThingML \cite{ThingMLcore} in the modeling process and Proteus for simulation.

%n this work, the authors showed how MDE techniques may support the development of IoT applications by also managing their intrinsic heterogeneity and complexity.

%Muccini H. \etal \cite{CAPS} presented CAPS, an architecture-driven modeling framework for developing situational aware cyber-physical systems. CAPS employs a multi-view architectural approach that combines software component design and interactions, hardware specification for situational awareness, and the physical environment where hardware equipment is deployed. %The approach also supports platform-specific code generation using ThingML \cite{ThingMLcore}.

Monitor-IoT \etal \cite{MonitorIoT} is a graphical designer based on the Obeo Designer Community and Eclipse Sirius tools. The framework allows developers to model IoT multi-layer monitoring architectures. The tool enables the definition of computing nodes and their resources that support the monitoring processes, \ie data collection, transport, processing, and storage. Monitor-IoT is flexible enough to support the modeling at the edge, fog, and cloud layers. 
%

\subsection{Mutation testing in fault analysis}
%With regard to the application of mutation testing in the design of software tests and evaluation of the quality of existing ones, we found different works in literature dealing with such a concern.
Praphamontripong \etal \cite{Praphamontripong2010} present an approach to testing Web applications by applying mutation analysis to the connections among Web application software components. The authors showed the effectiveness of mutation analyses in creating tests supporting fault detection. The proposed type of analysis is able to discover also new mutation operators. 

Similarly, Moran \etal \cite{Moran2018} applied mutation testing in the context of mobile Android applications. Besides the application of empirically derived operations, the proposed tool supports the automation of the process of detecting potential mutant locations, generating mutants, and discovering new operations. 

%Also, this tool envisages the discovery and addition of new operators. Moreover, it was evaluated against other popular mutation testing tools for the Java language by proving to generate fewer non-compilable, trivial mutants.

%Similarly, Moran \etal \cite{Moran2018} applied mutation testing in the context of mobile Android applications. In the presented demo, they showed how their tool supports not only the application of empirically derived mutation operators but also the automation of the process of detecting potential mutant locations and generating mutants. Also, this tool envisages the discovery and addition of new operators. Moreover, it was evaluated against other popular mutation testing tools for the Java language by proving to generate fewer non-compilable, trivial mutants.

Humbatova \etal \cite{Humbatova2021} present an approach for testing Deep Learning (DL) solutions. The authors extracted mutation operators from existing fault taxonomies. Then, they assessed the mutation operators to understand whether they produce killable, but not trivial, mutations. Eventually, they evaluated the approach by comparing it with the existing DeepMutation++ DL mutation tool. The results showed that their operators can discriminate more effectively between a weaker from a more robust test set.


Belli \etal \cite{BELLI201625} propose a model-based mutation testing approach for industrial systems based on directed graphs. The approach generates mutants and injects faults at the model level. In such a way, the mutation testing strategy can be applied even when the source code is unavailable. They only use two mutation operators, omission and insertion, by means of directed graphs. Then, these graphs are semantically enriched and exemplified using a collection of graph-based models to generate other operators.

%The applicability of the proposed approach was evaluated on industrial and commercial real-life systems by proving the support to testers in detecting faults in publicly released systems.

%Belli \etal \cite{BELLI201625} propose a model-based mutation testing approach for industrial and commercial real-life systems. The goal of the approach is to generate mutants based on the system's model under consideration and inject faults into the model rather than the implementation. This allows mutation testing even in systems where the source code is unavailable.
%They only use two mutation operators, omission and insertion, by means of directed graphs. Then, these graphs are semantically enriched and exemplified using a collection of graph-based models to generate other operators.
%The applicability of the proposed approach was evaluated on industrial and commercial real-life systems by proving the support to testers in detecting faults in publicly released systems.


\subsection{Specification Mining}

Concerning the understanding of system behaviour, \emph{specification mining}, intended as the extraction of high-level specifications from existing code, may play a key role. Approaches exploiting mined specifications can be used for program understanding but also for formal verification.


%The common issues of these approaches are related to the limitations from the observed executions. 
%In particular, they suffer from limited numbers of observations. For instance, if a piece of code is not executed, it is not considered in the specification, and also, if it is executed only once, it leaves no trace of alternative behavior in the specifications.
%

Dallmeier \etal \cite{Dallmeier2010} propose \emph{TAUTOKO}, a typestate 
 miner that combines systematic test case generation and typestate mining. Using those strategies. the approach systematically extends the execution space and enriches the final specification by increasing true positives. 

%Dallmeier \etal \cite{Dallmeier2010} highlight that specification mining is promising, but its effectiveness depends on the observed executions. They developed \emph{TAUTOKO}, a typestate miner that generates test cases covering systematically extending the execution space and enriching the specification by combining systematic test case generation and typestate mining. The authors observed that with enriched specifications, the typestate verifier produces significantly more true positives and significantly fewer false positives.

The need for good specifications for effective system verification is also highlighted by Cao \etal \cite{Cao2018RulebasedSM}. They adopted a rule-based specification mining approach that explores the
search space of all possible rules and uses interestingness measures to differentiate specifications from false positives. Then, the authors propose a learning-to-rank-based approach to consider 38 available interestingness measures together and investigate their combinations.
Their experiment results show that the learning-to-rank-based approach can improve the best ranking performance using a single measure by up to 66\%.

 \emph{ARTINALI++} \cite{ALIABADI2021111016} tool dynamically mines specifications of Complex Cyber-Physical Systems (CPS) to manage security issues. The approach generates a multi-dimensional model that is capable of embodying time, data, and events into the specifications. \emph{ARTINALI++} has been validated using three CPS platforms for intrusion detection. The results showed an average of 97.7\% detection accuracy across platforms while incurring reasonable performance and memory overheads.

%In the context of Complex Cyber-Physical System (CPS) Security, Aliabadi \etal \cite{ALIABADI2021111016} developed a tool that dynamically mines specifications in such systems with arbitrary size and complexity, generating a multi-dimensional model for the general system. Moreover, the authors envisaged the incorporation of time into the specifications, in addition to data and events, by highlighting the importance of this temporal dimension in CPS systems. The developed tool, called \emph{ARTINALI++}, was applied on three CPS platforms for intrusion detection. The results showed an average of 97.7\% detection accuracy across platforms while incurring reasonable performance and memory overheads.