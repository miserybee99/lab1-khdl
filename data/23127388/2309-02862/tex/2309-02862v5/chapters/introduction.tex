\section{Introduction}
Most modern architectures, such as Intel x86 \cite{x86-swdmanual-1-3}, SPARC \cite{sparc9}, IBM's POWER \cite{power-isa-v31b}, and ARM \cite{arm-v7ar-refman}, implement several relaxations and optimisations that reduce the latency of memory accesses. This has the effect of breaking the Sequential Consistency (SC) assumption \cite{DBLP:journals/tc/Lamport79}. SC is the classical strong semantics for concurrent programs that interleaves the parallel executions of processes while maintaining the order in which instructions were issued. Programmers usually assume that the execution of programs follows the SC model. However, this is not true when we consider concurrent programs running on modern architectures. In fact, even simple programs such as mutual exclusion and producer-consumer protocols, that are correct under SC, may exhibit erroneous behaviours. This is mainly due to the relaxation of the execution order of the instructions. For instance, a standard relaxation is to allow the reordering of reads and writes of the same process if the reads have been issued after the writes and they concern different memory locations. This relaxation can be implemented using an unbounded perfect FIFO queue/buffer between each process and the memory. These buffers are used to store delayed writes. The corresponding model is called Total Store Ordering (TSO) and corresponds to the formalisation of SPARC and Intel x86 ~\cite{DBLP:conf/tphol/OwensSS09,DBLP:journals/cacm/SewellSONM10}.

\input{figures/dekker}

A process of a concurrent program is modelled as a finite-state transition system. Each transition is labelled with an instruction that describes how it interacts with the shared memory. For instance, the process can read a value from or write a value to a shared variable. The data domain of these instructions is assumed to be finite. More complex instructions like comparisons or arithmetic operations, and infinite data structures managed locally by the process are abstracted through the nondeterminism of the process. An example of a concurrent program is given in \autoref{fig:dekker}, which shows the Dekker protocol for mutual exclusion. Under SC semantics, it is not possible for both processes to simultaneously reach the critical sections $\state_3$ and $\rstate_3$, respectively.

In TSO, an unbounded buffer is associated with each process. When a process executes a write operation, this write is appended to the end of the buffer of that process. A pending write operation on the variable $\xvar$ at the head of a buffer can be deleted in a non-deterministic manner. This updates the value of the shared variable $\xvar$ in the memory. To perform a read operation on a variable $\xvar$, the process first checks its buffer for a pending write operation on the variable $\xvar$. If such a write exists, then the process reads the value written by the newest pending write operation on $\xvar$. Otherwise, the process fetches the value of the variable $\xvar$ from the memory.

Under TSO, both processes of the Dekker protocol in \autoref{fig:dekker} can reach the critical sections $\state_3$ and $\rstate_3$ simultaneously, thus violating mutual exclusion. This can happen since after executing $\wr(\xvar, 1)$, the operation only resides in the buffer of $\process^1$ and is invisible to $\process^2$. The converse holds for the write instruction of $\process^2$. Thus, both processes are able to read the initial value $0$ from the variable $\yvar$ or $\xvar$, respectively.

In general, verification of programs running under TSO is challenging due to the unboundedness of the buffers. In fact, the induced state space of a program under TSO may be infinite even if the program itself is a finite-state system.

The reachability problem for programs under TSO checks whether a given program state is reachable during program execution. It is also called safety problem, in case the target state is considered to be a bad state. It has been shown decidable using different alternative semantics for TSO (e.g. \cite{DBLP:conf/popl/AtigBBM10,DBLP:conf/tacas/AbdullaACLR12,DBLP:journals/lmcs/AbdullaABN18}). These alternative semantics, such as the load-buffer semantics in contrast to the traditional store-buffer semantics, provide different formalisations of TSO. While they differ in how they model specific aspects of memory behaviour, they are equivalent with respect to the reachability of program states.

Furthermore, it has been shown in \cite{DBLP:conf/popl/AtigBBM10} that lossy channel systems (see e.g., \cite{wsts2,wsts1,DBLP:conf/icalp/AbdullaJ94,DBLP:journals/ipl/Schnoebelen02}) can be simulated by programs running under TSO. This entails that the reachability problem for programs under TSO is non-primitive recursive and that the repeated reachability problem is undecidable. This is an immediate consequence of the fact that the reachability problem for lossy channel is non-primitive recursive \cite{DBLP:journals/ipl/Schnoebelen02} and that the repeated reachability problem is undecidable \cite{DBLP:conf/icalp/AbdullaJ94}. The termination problem for programs running under TSO has been shown to be decidable in \cite{DBLP:journals/siglog/Atig20} using the framework of well-structured transition systems \cite{DBLP:conf/icalp/Finkel87,wsts1,wsts2}.

The authors of \cite{DBLP:conf/esop/BouajjaniDM13,DBLP:conf/icalp/BouajjaniMM11} consider the robustness problem for programs running under TSO. This problem consists in checking whether, for any given TSO execution, there is an equivalent SC execution of the same program. Two executions are declared equivalent by the robustness criterion if they agree on (1) the order in which instructions are executed within the same process (i.e., program order), (2) the write instruction from which each read instruction fetches its value (i.e., read-from relation), and (3) the order in which write instruction on the same variable are committed to memory (i.e., store ordering). The problem of checking whether a program is robust has been shown to be \pspace-complete in \cite{DBLP:conf/esop/BouajjaniDM13}. A variant of the robustness problem which is called persistence, declares that two runs are equivalent if (1) they have the same program order and (2) all write instructions reach the memory in the same order. Checking the persistency of a program under TSO has been shown to be \pspace-complete in \cite{DBLP:conf/esop/AbdullaAP15}. Observe that the persistency and robustness problems are stronger than the safety problem (i.e., if a program is safe under SC and robust/persistent, then it is also safe under TSO).

Due to the non-determinism of the buffer updates, the buffers associated with each process under TSO appear to exhibit a lossy behaviour. Previously, games on lossy channel systems (and more general on monotonic systems) were studied in \cite{DBLP:journals/logcom/AbdullaBd08}. Unfortunately these results are not applicable / transferable to programs under TSO whose induced transition systems are not monotone \cite{DBLP:conf/popl/AtigBBM10}.

In this paper, we consider a natural continuation of the works on both the study of the decidability/complexity of the formal verification of programs under TSO and the study of games on concurrent systems. This is further motivated by the fact that formal games provide a framework to reason about a system's behaviour, which can be leveraged in control model checking, for example in controller synthesis problems. In particular, games can model the adversarial nature of certain problems where one component tries to achieve a goal while another tries to prevent it. This is especially relevant in the context of concurrent programs running under relaxed memory models like TSO, where the non-deterministic behaviour of memory can be seen as an adversary to the correctness of the program.

One specific problem that can be modeled by our approach is the controller synthesis problem (e.g. \cite{DBLP:conf/popl/PnueliR89,kupferman1997synthesis,DBLP:conf/mfcs/KupfermanV00}). In this context, the goal is to design a controller (player A) that ensures a system (player B) behaves correctly despite the uncertainties introduced by the memory model. The game framework allows us to formally define the objectives of the controller and the system, and to analyse whether a winning strategy exists for the controller. If such a strategy exists, it corresponds to a correct implementation of the controller that guarantees the desired behaviour of the system \cite{1316713,ARNOLD20037}.

Another problem that can be modeled by our approach is the verification of safety properties in concurrent programs. By framing the verification problem as a game, we can leverage game-theoretic techniques to determine whether a program can reach an undesirable state (a losing condition for player A). This approach provides a clear and formal method to analyse the safety of concurrent programs under TSO and other relaxed memory models.

Additionally, our approach lays the foundation for future research. For instance, by adding weights to the instructions/transitions, we can model fence insertion problems \cite{DBLP:conf/esop/AbdullaAP15}. This could be done by giving a player the choice to take a memory fence instruction or not, but we assign a penalty cost to each memory fence transition. An optimal, that is lowest-cost, winning strategy corresponds to the minimal amount of memory fences that need to be inserted into the program to ensure memory consistency. This is crucial for optimising the performance of concurrent programs under relaxed memory models.

In more detail, we consider (safety) games played on the transition systems induced by programs running under TSO. Given a program under TSO, we construct a game in which two players, A and B, take turns executing instructions. Player B aims to reach a given set of final configurations, while player A tries to prevent this, making it a reachability game from the perspective of player B. The turn structure determines which player executes the next instruction, but it does not specify how memory updates occur. To address this, we allow players to update memory by removing pending writes from the buffer between instruction executions.

In some variants, only player A (considered to be the \emph{good} player) has control over memory updates. These correspond to the problem of synthesizing an update controller that ensures correct execution despite an adversarial opponent. In other variants, only player B (the \emph{bad} player) has control over updates, modelling the problem of synthesising a process or program under a non-cooperative update mechanism. In both cases, the precise timing of updates remains unclear â€” whether they occur before, after, or both before and after a player's turn. Additionally, there may be scenarios where it is beneficial to allow both players to update memory, depending on the problem setting.

Considering all these possibilities results in 16 different TSO game variants. While not all are equally relevant in practice, we analyse them for completeness, as they may provide insights for future research and yet unknown applications. We divide these 16 games into four different groups, depending on their decidability results.
\begin{itemize}
    \item Group I (7 games) can be reduced to TSO games with 2-bounded buffers.
    \item Group II (1 game) can be reduced to TSO games with bounded buffers.
    \item Group III (7 games) can simulate perfect channel systems.
    \item Group IV (1 game) can be reduced to a finite game without buffers.
\end{itemize}
This classification is shown in \autoref{fig:tso-groups}. Of these four groups, only Group III is undecidable, the others each reduce to a finite game and are thus decidable. Coincidentally, the undecidable group contains all of the most interesting variants, where exactly one of the two players can update memory.

\begin{figure}
\newcommand{\gr}[1]{\cellcolor{gray!#1}}
\renewcommand{\arraystretch}{1.25}
\centering
\def\wdth{0.12\textwidth}
\begin{tabular}{p\wdth C\wdth C\wdth!{\vrule width -1pt} C\wdth!{\vrule width -1pt} C\wdth!{\vrule width -1pt} C\wdth}
    \toprule
    & & \multicolumn{4}{c}{Player A:} \\
    & & always & before & after & never \\
    \midrule
    \multirow{4}{0.15\textwidth}{Player B:}
    & always    & \gr{20} I (d) & \gr{20}       & \gr{20}           & \gr{40}       \\[-1pt]
    & before    & \gr{20}       & \gr{0} II (d) & \gr{20}           & \gr{40}       \\[-1pt]
    & after     & \gr{20}       & \gr{20}       & \gr{40} III (u)   & \gr{40}       \\[-1pt]
    & never     & \gr{40}       & \gr{40}       & \gr{40}           & \gr{60} IV (d)\\
    \bottomrule
\end{tabular}
\caption{Groups of TSO games, where players A and B are allowed to update the buffer: always, before their own move, after their own move, or never. The games in group I (light grey), II (white) and IV (dark grey) are decidable (d), the games in group III (medium grey) are undecidable (u).}
\label{fig:tso-groups}
\end{figure}

Finally, we establish the exact computational complexity for the decidable games. In fact, we show that the problem is \exptime-complete. We prove \exptime-hardness by a reduction from the problem of acceptance of a word by a polynomially bounded alternating Turing machine \cite{DBLP:conf/focs/ChandraS76,DBLP:journals/jacm/ChandraKS81}. This result holds even in the case for games played on a single-process concurrent program following SC semantics. To prove \exptime-membership, we show that it is possible to compute the winning regions for the players in exponential time. These results are surprising given the non-primitive recursive complexity of the reachability problem for programs under TSO and the undecidability of the repeated reachability problem.

This paper is an extended and revised version of the conference paper \cite{DBLP:journals/corr/abs-2310-00990}. We present the formal proof of the lower complexity bound for the decidable games. These now also include the newly defined SC games, which are games played on programs following SC semantics. We utilise the framework of bisimulations to lift complexity results from SC games to TSO games, and to streamline the \exptime-completeness proof of group IV. Furthermore, the appendix presents a formal proof of the undecidability result for the games in group III. We generally revised all sections of this paper. It contains clarifications, more elaborate explanations, and additional examples and figures.

\smallskip

\noindent
{\bf Related Works.}
In addition to the related work mentioned in the introduction on the decidability / complexity of the verification problems of programs running under TSO, there have been some works on parameterized verification of programs running under TSO. The problem consists in verifying a concurrent program regardless of the number of involved processes (which are identical finite-state systems). The parameterised reachability problem of programs running under TSO has been shown to be decidable in \cite{DBLP:conf/concur/AbdullaABN16,DBLP:journals/lmcs/AbdullaABN18}. While this problem for concurrent programs performing only read and writing operations (no atomic read-write instructions) is \pspace-complete \cite{DBLP:journals/pacmpl/AbdullaAR20}. This result has been recently extended to processes manipulating abstract data types over infinite domains \cite{DBLP:conf/tacas/AbdullaAFGHKS23}. Checking the robustness of a parameterised concurrent system is decidable and \expspace-hard \cite{DBLP:conf/esop/BouajjaniDM13}.

As far as we know this is the first work that considers the game problem for programs running under TSO. The proofs and techniques used in this paper are different from the ones used to prove decidability / complexity results for the verification of programs under TSO except the undecidability result which uses some ideas from the reduction from the reachability problem for lossy channel systems to its corresponding problem for programs under TSO \cite{DBLP:conf/popl/AtigBBM10}. However, our undecidability proof requires us to implement a protocol that detects lossiness of messages in order to turn the lossy channel system into a perfect one (which is the most intricate part of the proof).
